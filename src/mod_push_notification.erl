-module(mod_push_notification).
-author('Your Name').

-behaviour(gen_mod).

-include("logger.hrl").
-include("xmpp.hrl").
-include("pubsub.hrl").
-include("translate.hrl").

%% gen_mod callbacks
-export([start/2, stop/1, depends/2, mod_options/1, mod_doc/0, mod_opt_type/1]).
-export([on_filter_packet/1]).

-define(PUSH_CACHE, push_cache).
-define(DEFAULT_PUSH_URL, "https://pushtriplechat.azurewebsites.net/api/SendPushNotification").

start(Host, _Opts) ->
    ?INFO_MSG("Starting mod_push_notification v2 for host ~s", [Host]),
    ejabberd_hooks:add(filter_packet, global, ?MODULE, on_filter_packet, 50),
    ok.

stop(Host) ->
    ?INFO_MSG("Stopping mod_push_notification for host ~s", [Host]),
    ejabberd_hooks:delete(filter_packet, global, ?MODULE, on_filter_packet, 50),
    ok.

depends(_Host, _Opts) ->
    [].

mod_options(_Host) ->
    [{push_url, ?DEFAULT_PUSH_URL},
     {multi_token, false}].

mod_opt_type(push_url) ->
    econf:url();
mod_opt_type(multi_token) ->
    econf:bool().

mod_doc() -> #{
    desc =>
        ?T("This module captures push notification IQs generated by mod_push "
           "and forwards them to a specified HTTP endpoint."),
    opts =>
        [{push_url,
          #{value => "URL",
            desc =>
                ?T("The URL of the HTTP endpoint to which push notifications "
                   "will be forwarded. Default: ") ++ iolist_to_binary(?DEFAULT_PUSH_URL)}},
         {multi_token,
          #{value => "true | false",
            desc =>
                ?T("When set to true, the module will split the node for APNS "
                   "platforms and use different tokens for message and VoIP "
                   "notifications. Default: false")}}]
}.

on_filter_packet(Packet) ->
    case Packet of
        #iq{type = set, to = #jid{luser = <<>>, lresource = <<>>},
            sub_els = [#pubsub{publish = #ps_publish{node = Node, 
                                                     items = [#ps_item{id = _Id, 
                                                                       sub_els = [#push_notification{xdata = #xdata{fields = XDataFields}}]}]},
                               publish_options = #xdata{fields = Fields}}]} ->
            ?INFO_MSG("Captured push notification IQ",[]),
            process_push_notification(Node, XDataFields, Fields);
        _ ->
            ok
    end,
    Packet.

process_push_notification(Node, XDataFields, Fields) ->
    % Campos específicos que extraemos primero
    SpecificKeys = [<<"FORM_TYPE">>,<<"notification-type">>, <<"pushModule">>],
    
    % Extraer campos específicos
    NotificationType = find_field_value(<<"notification-type">>, Fields),
    Platform = find_field_value(<<"pushModule">>, Fields),
    Environment = find_field_value(<<"environment">>, Fields),
    
    % Extraer campos de XDataFields
    Title = find_field_value(<<"last-message-sender">>, XDataFields),
    Body = find_field_value(<<"last-message-body">>, XDataFields),
    
    % Crear el mapa de datos con todos los campos restantes de Fields
    DataFields = [{binary_to_atom(Var, utf8), Value} || 
                  #xdata_field{var = Var, values = [Value]} <- Fields,
                  not lists:member(Var, SpecificKeys)],
    
    % Determinar el token basado en multi_token y platform
    Token = case gen_mod:get_module_opt(global, ?MODULE, multi_token) of
        true when Platform == <<"apns">> ->
            [TokenVoIP, TokenMessage] = binary:split(Node, <<"@@@">>),
            case NotificationType of
                <<"call">> -> TokenVoIP;
                _ -> TokenMessage
            end;
        _ ->
            Node
    end,
    
    Payload = jiffy:encode({[
        {<<"token">>, Token},
        {<<"title">>, Title},
        {<<"body">>, Body},
        {<<"data">>, {DataFields}},
        {<<"type">>, NotificationType},
        {<<"platform">>, Platform},
        {<<"environment">>, Environment}
    ]}),
   
    Headers = [
        {"Content-Type", "application/json"}
    ],
    
    PushURL = gen_mod:get_module_opt(global, ?MODULE, push_url),
    
    ?INFO_MSG("Sending Push notification Payload: ~p", [Payload]),

    case httpc:request(post, {PushURL, Headers, "application/json", Payload}, [], []) of
        {ok, {{_, 200, _}, _, ResponseBody}} ->
            ?INFO_MSG("Push notification forwarded successfully. Response: ~p", [ResponseBody]);
        {ok, {{_, StatusCode, _}, _, ResponseBody}} ->
            ?ERROR_MSG("Failed to forward push notification. Status code: ~p, Response: ~p", [StatusCode, ResponseBody]);
        {error, Reason} ->
            ?ERROR_MSG("Error forwarding push notification: ~p", [Reason])
    end.

find_field_value(Var, Fields) ->
    case lists:keyfind(Var, #xdata_field.var, Fields) of
        #xdata_field{values = [Value|_]} -> Value;
        _ -> <<>>
    end.
